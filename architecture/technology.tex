\section{Technologie}\label{architektur.technologie}
	Für die Umsetzung von \eeppi\ haben wir uns für verschiedene Technologien entschieden.
	Die Evaluation sowie die Technologien selbst werden nachfolgend beschrieben.

	\subsection{Server}
		Die Erstellung einer Webanwendung ist Teil der Anforderungen von \eeppi.
		Als Erstes wird im folgenden Abschnitt die Auswahl der Servertechnologie beschrieben.

		\subsubsection{Evaluation}
			\label{serverEvaluation}
			
			Die Servertechnologie stellt eine entscheidende Komponente dar, 
			ihre Wahl ist von entsprechender Tragweite für andere Komponenten des Projektes.
			Aus diesem Grund haben wir sie ausführlich evaluiert.
			
			\begin{enumerate}
				\item Schritt: Gemeinsame Definition von Kriterien und möglichen Servertechnologien.
				\item Schritt: Separate Festlegung der Gewichtung der Kriterien sowie Definition der Matrix Kriterium/Servertechnologie mit der persönliche Schätzung, wie stark jede Servertechnologie das entsprechende Kriterium erfüllt.
				\item Schritt: Zusammenführung der persönlichen Ergebnisse zu Gesamtergebnis
			\end{enumerate}
		
			\begin{figure}[H]
				\begin{minipage}[b]{\linewidth}
					\includegraphics[width=\textwidth]{media/spreadsheets/ServertechnologieVergleichPrioritaetsfinding.pdf}
					\centering
					\caption{Servertechnologie-Vergleich: Prioritätsfindung}
					\label{fig:ServertechnologieVergleichPrioritaetsfinding}
				\end{minipage}
			\end{figure}
			
			Abbildung~\ref{fig:ServertechnologieVergleichPrioritaetsfinding} zeigt den Prozess der Prioritätsfindung.
			Wie bereits erwähnt, haben wir zuerst die Kriterien definiert und 
			anschliessend je separat Prioritäten für jedes Kriterium festgelegt.
			Da wir verschiedene Skalen verwendet haben, haben wir unsere Punkte noch zu 100\% normiert.
			Und aus diesen zwei Werten haben wir in gemeinsamer Diskussion die definitive Priorität erstellt.
			Dies hat meist problemlos funktioniert, ausser bei den Punkten "<Kenntnisse im Team"> und "<Unterstützung von Hosting Providern"> (blau markiert) hatten wir zu Beginn nennenswerte Unterschiede.
			Bei diesen Punkten haben wir dann in der gemeinsamen Diskussion einen Wert festgelegt.
		
			\begin{figure}[H]
				\begin{minipage}[b]{\linewidth}
					\includegraphics[width=\textwidth]{media/spreadsheets/ServertechnologieVergleichVergleichDerTechnologien.pdf}
					\centering
					\caption{Servertechnologie-Vergleich: Vergleich der Technologien}
					\label{fig:ServertechnologieVergleichVergleichDerTechnologien.pdf}
				\end{minipage}
			\end{figure}
			
			Abbildung~\ref{fig:ServertechnologieVergleichVergleichDerTechnologien.pdf} zeigt den Vergleich der einzeln evaluierten Servertechnologien.
			Auch hier haben wir zuerst je separat die Schätzung gemacht und dann verglichen.
			Bei diesem Vergleich haben wir sehr ähnliche Werte gewählt, lediglich bei den Zukunftsaussichten von PHP, Flow und Doctrine (blau markiert) hatten wir nennenswert unterschiedliche Ansichten.
			
			\begin{figure}
					\includegraphics[width=\textwidth]{media/img/EntwicklungVonWebserverTechnologien.png}
					\centering
					\caption{Entwicklung von Webserver"=Technologien der Top 10'000 Sites \cite{builtwith_pty_ltd_framework_2014}}
					\label{fig:EntwicklungVonWebserverTechnologien}
			\end{figure}
			
			Schlussendlich haben wir uns nach Recherchen auf eine "<1"> geeinigt, weil entgegen den Erwartungen von Laurin Murer sich die Verbreitung von PHP (auch bei grösseren Seiten) kaum verändert hat in den letzten Jahren.
			Als Beispiel für eine Technologie, die immer weniger eingesetzt wird und in den nächsten Jahren verschwinden wird, haben wir Shockwave Flash herangezogen, welche, wie in Abbildung~\ref{fig:EntwicklungVonWebserverTechnologien} sichtbar, im letzten Jahr deutlich an Boden verloren hat.
			Im Vergleich dazu ist PHP sehr gut im Markt vertreten und besitzt auch eine äusserst konstante Verbreitung.
			Deshalb, und unter dem Gesichtspunkt der soliden Konzepte, 
			die den in den letzten Jahren entstandenen modernen PHP Frameworks wie Doctrine und Flow zugrunde liegen, sehen wir da auch das Fortbestehen für diese Technologien gegeben.
			
			\begin{figure}[H]
				\begin{minipage}[b]{\linewidth}
					\includegraphics[width=\textwidth]{media/spreadsheets/ServertechnologieVergleichVergleichDerTechnologienDiagramm.png}
					\centering
					\caption{Ergebnis Servertechnologie-Vergleich}
					\label{fig:ErgebnisServertechnologieVergleich}
				\end{minipage}
			\end{figure}
		
		
		\subsubsection{Ergebnis}
			\label{serverEvaluationErgebnis}				
			
			Schlussendlich haben wir für jede Technologie das Total der Punkte berechnet (Punkte jedes Kriteriums multipliziert mit seiner Priorität).
			In Abbildung~\ref{fig:ErgebnisServertechnologieVergleich} ist das Ergebnis abgebildet.
			Aufgrund diesem haben wir uns für das Play Framework entschieden.
			Eine Alternative wäre noch Node.js mit TypeScript gewesen, diese erreichte jedoch, aufgrund der Präferenz des Betreuers für Java und der schlechteren Unterstützung durch Hostingangebote, 10\% weniger Punkte.
			
			
		\decision{
			\decisionHeader{TEC-SERVER}{Servertechnologie}{Technologie}{Server}
		}{
			\decisionContent{Play Framework}
			{Welche Servertechnologie soll eingesetzt werden?}
			{Die einzusetzende Technologie erlaubt die ausgewählte Tier-Architektur-Variante}
			{Von der Servertechnologie hängen unter Anderem die Entscheidungen für Server und Persistenz Framework ab.}
			{\cdar\ erweitern, eigener Tomcat, Node.js+JS, Node.js+TS, Ruby, PHP}
			{			
				\begin{itemize}
					\item Das Play Framework basiert auch auf Java, wie das bestehende \cdar.
					\item Ein Teammitglied hat bereits Erfahrungen mit dem Framework gemacht.
					\item Das andere Teammitglied kennt die zugrundeliegende Sprache (Java).
					\item Der Betreuer hat eine Präferenz für Java.
					\item Das Play Framework benötigt wenig Boilerplate-Code\footnote{Code, der (wiederholt) geschrieben werden muss, ohne dass er wirklich etwas zum Projekt beiträgt}.
					\item Es sprechen keine zwingenden Gründe dagegen (wie beispielsweise zu stark einschränkende Lizenzen).
					\item Das Play Framework ist angenehm zum Entwickeln für die Entwickler: gegebener Spass-Faktor, Vermeidung von Fehlern, Unterstützung im Erreichen von guter Code Qualität.
					\item Im IFS\footnote{Institut für Software, HSR Hochschule für Technik: \url{http://www.ifs.hsr.ch/}} ist Know How zum Play Framework vorhanden (M. Stocker).
				\end{itemize}
			}
			{keine}
			{Potentielle Hosting Provider müssen Java unterstützen}
			{
				\decisionRef{Tier Architektur}{ARC-TIERS}
			}
		}

		\subsubsection{Play Framework}
			Kapitel~\ref{serverEvaluation} erläutert den Hintergrund der Entscheidung für das Play Framework. 
			
			Wikipedia beschreibt das Play Framework wie folgt:
			\begin{quote}
				"<Play is an open source web application framework, written in Scala and Java, which follows the model–view–controller (MVC) architectural pattern. It aims to optimize developer productivity by using convention over configuration, hot code reloading and display of errors in the browser."> \cite{builtwith_pty_ltd_framework_2014}
			\end{quote}
			

	\subsection{Client}
		Nachfolgend wird die Auswahl der Technologien für die Clientseite der Applikation beschrieben.

		\subsubsection{Sprache}
		JavaScript ist die einzige clientseitige Sprache, die von allen Browsern ohne Installation eines Plugins unterstützt wird. Entsprechend haben wir in diesem Bereich keine Wahlmöglichkeit. Es gibt jedoch einige Precompiler\footnote{Compiler, der Code einer andern Sprache in JavaScript umwandelt, bevor dieser ausgeführt wird.}, die verschiedene Vor- und Nachteile bieten.

		\decision{
			\decisionHeader{TEC-CLIENT-LANG}{Clientseitige Programmiersprache}{Technologie}{Sprache}
		}{
			\decisionContent{TypeScript}
			{Welche Sprache soll clientseitig verwendet werden?}
			{Der eingesetzte Build-Server unterstützt Precompiling für JavaScript 
			oder bietet das starten eigener Skripte an}
			{Diese Entscheidung beeinflusst die Optionen der Client Frameworks und sie entscheidet, ob die gewählte Sprache gutes Code-Schreiben unterstützt, wenig fehleranfällig ist und Fehler frühzeitig erkannt werden können, oder ob die Sprache Fehler begünstigt und damit die Qualität des Codes verringert.}
			{
				\begin{description}
					\item[JavaScript] \
						\begin{description}
							\item[Vorteile] UI der bestehenden Applikation ist auch in JavaScript geschrieben
							\item[Nachteile] Fehler tauchen erst zur Runtime auf, sprachspezifische Besonderheiten, die Fehler begünstigen
						\end{description}
					\item[Dart] \
						\begin{description}
							\item[Vorteile] Moderne, optional typisierte, kompilierte Programmiersprache (wird zu JS kompiliert)
							\item[Nachteile] Benötigt Dart VM oder Dart-to-JS Transcompiler, wenig verbreitet
						\end{description}
				\end{description}
			}{TypeScript wird zu JavaScript kompiliert, sodass die Vorteile beide Sprachen kombiniert werden. TypeScript versucht, möglichst den Standard zukünftiger ECMA-Script Versionen einzuhalten, sodass die Kompatibilität immer gewährleistet und die Syntax möglichst ähnlich bleiben soll.
			\begin{description}
				\item[Vorteile] Optisch besser lesbar als JavaScript, verhindert bekannte, häufige Probleme in JavaScript wie zum Beispiel das ungewohnte verhalten von "<this">, verbessert die Codequalität gegenüber JavaScript massiv, da viele Fehler zur Kompilierzeit gefunden werden
				\item[Nachteile] Erfordert TSC\footnote{TypeScript Compiler, kann über den Node-Packagemanager von Node.js installiert werden}-Compiler, Code Overhead bei Inheritance
			\end{description}
			}{keine}
			{Die Entwicklungsumgebung benötigt Node.js für den TypeScript Compiler.}
			{
				\decisionRef{Tier Architektur}{TEC-CLIENT-FW}
			}
		}
			
			
		\subsubsection{Architektur-Framework}
		Um clientseitig eine grössere Applikation aufzubauen, gibt es verschiedene Möglichkeiten. Einerseits kann selbst ein Mini-Framework entwickelt werden, andererseits gibt es viele weit entwickelte Frameworks mit grossem Funktionsumfang.
		

			\decision{
				\decisionHeader{TEC-CLIENT-FW}{Clientseitiges Applikationsframework}{Technologie}{Framework}
			}{
				\decisionContent{AngularJS}
				{Welches Applikationsframework soll clientseitig eingesetzt werden?}
				{Es wird eine clientzentrierte oder verteilte Applikation entwickelt}
				{Diese Entscheidung legt den Grundstein für den technologischen Aufbau der clientseitigen Applikation und soll ein Framework evaluieren, 
				das Templating und Two-Way-Binding mit UI Komponenten unterstützen, 
				um dies nicht selbst implementieren zu müssen.}
				{
					\begin{description}
						\item[EmberJS] \
							\begin{description}
								\item[Vorteile] Sehr modular und anpassbar, weniger Overhead als AngularJS
								\item[Nachteile] Bringt wesentlich weniger mit als Angular JS, mehr Eigenaufwand notwendig, kann nur einfache Datentypen an UI Elemente binden
							\end{description}
						\item[Kein Framework] \
							\begin{description}
								\item[Vorteile] Vollständig freie Architekturgestaltung
								\item[Nachteile] Hoher Implementationsaufwand ohne Gewinn
							\end{description}
					\end{description}
				}
				{AngularJS ist ein bekanntes MVW\footnote{Model View Whatever:
				Fasst MVC, MVP und andere ähnliche Strukturierungspatterns zusammen, wird manchmal auch "<MV*\hspace{0.05em}"> genannt.
				}- und Templating-Framework, erlaubt eine saubere Trennung von Logik
				und Darstellung und bindet ViewModel-Eigenschaften und "=Funktionen ans Template.
				Dadurch lassen sich Observer-Konstrukte sparen.
				AngularJS ist stabil, zuverlässig, gut erweiterbar und bringt von sich aus schon sehr viel mit gegenüber EmberJS. Es wurde auch schon für das bestehende \dks\ \cdar eingesetzt.}
				{keine}
				{Die Serverkomponente muss eine Schnittstelle bieten, 
				über welche die Clientapplikation Daten austauschen kann.}
				{
					\decisionRef{Client Sprache}{TEC-CLIENT-LANG},
					\decisionRef{Tier Architektur}{ARC-TIERS}
				}
			}
		
			
			\subsubsection{JavaScript Autoloading}
				Ursprünglich wurde die Idee diskutiert, Require.js als Autoloader zu benutzen.
				Require.js bietet nebst Vorteilen wie Namespacing und Autoloading leider den grossen Nachteil,
				dass jedes Skript einzeln asynchron vom Client angefordert wird, 
				was insbesondere bei grösseren Round-Trip-Times die Applikation spürbar verlangsamt.
				Aus diesem Grund wurde entschieden, 
				auf die Module von TypeScript zur Strukturierung zu setzen  
				und die verschiedenen Skripte bereits beim Kompilieren zusammenzuführen.
				

			\subsubsection{Styling}
				Das Frontend der Clientapplikation wird mit CSS\footnote{Cascading Style Sheets: Auszeichnungssprache für Webdokumente, um diese grafisch zu gestalten} gestaltet.
				Um dieses einfacher schreiben zu können,
				wird Less\footnote{CSS Pre-Prozessor: \url{http://lesscss.org/}} als CSS Preprocessor\footnote{Vorverarbeitungsschritt, 
				bei dem Code einer andern Sprache in CSS umgewandelt wird} eingesetzt, 
				da es schlankeren Sourcecode ermöglicht und Vorteile wie Variablen und Mixins bietet.
				Less wird serverseitig kompiliert um den Client zu entlasten.
				
				
		\subsection{Testing}
			Das Testframework für den Clientteil soll einfach einzubinden und zu erweitern sein. 
			Mit "<erweitern"> ist in diesem Falle gemeint, neue Tests und Testsuits hinzuzufügen.
			Ebenfalls soll es eine Syntax ähnlich der Assert-Syntax von JUnit bieten und mit einem Build Server gekoppelt werden können.
			

			\subsubsection{Jasmine}
				Jasmine arbeitet mit einem realen Browser (keine Browsersimulation), 
				ist einfach zu handhaben und bietet typische Assert-Syntax.
				Ausserdem wird es direkt von AngularJS promoted.
				
				
