\section{Technologie}
	\subsection{Server}

		\subsubsection{Evaluation}\label{serverEvaluation}
			Die Servertechnologie stellt eine entscheidende Komponente dar, 
			ihre Wahl ist von entschprechender Tragweite für andere Komponenten des Projektes.
			Aus diesem Grund haben wir sie ausführlich evaluiert.
			
			\begin{enumerate}
				\item Schritt: Gemeinsame Definition von Kriterien und möglichen Servertechnologien.
				\item Schritt: Sepparate Festlegung der Gewichtung der Kriterien sowie Definition der Matrix Kriterium/Servertechnologie mit der persönliche Schätzung, wie stark jede Servertechnologie das entsprechende Kriterium erfüllt.
				\item Schritt: Zusammenführung der persönlichen Ergebnisse zu Gesammtergebnis
			\end{enumerate}
		
			\begin{figure}[H]
				\begin{minipage}[b]{\linewidth}
					\includegraphics[width=\textwidth]{media/spreadsheets/ServertechnologieVergleichPrioritaetsfinding.pdf}
					\centering
					\caption{Servertechnologie-Vergleich: Prioritätsfinding}
					\label{fig:ServertechnologieVergleichPrioritaetsfinding}
				\end{minipage}
			\end{figure}
			
			Abbildung~\ref{fig:ServertechnologieVergleichPrioritaetsfinding} zeigt den Prozess der Prioritätsfindung.
			Wie bereits erwähnt, haben wir zuerst die Kriterien definiert und 
			anschliessend je separat Prioritäten für jedes Kriterium festgelegt.
			Da wir verschiedene Skalen verwendet haben, haben wir unsere Punkte noch zu 100\% normiert.
			Und aus diesen zwei Werten haben wir in gemeinsamer Diskussion die definitive Priorität erstellt.
			Dies hat meist problemlos funktioniert, ausser bei den Punkten "`Kenntnisse im Team"' und "`Unterstützung von Hosting Providern"' (blau markiert) hatten wir zu Beginn nennenswerte Unterschiede.
			Bei diesen Punkten haben wir dann in der gemeinsamen Diskussion einen Wert festgelegt.
		
			\begin{figure}[H]
				\begin{minipage}[b]{\linewidth}
					\includegraphics[width=\textwidth]{media/spreadsheets/ServertechnologieVergleichVergleichDerTechnologien.pdf}
					\centering
					\caption{Servertechnologie-Vergleich: Vergleich der Technologien}
					\label{fig:ServertechnologieVergleichVergleichDerTechnologien.pdf}
				\end{minipage}
			\end{figure}
			
			Abbildung~\ref{fig:ServertechnologieVergleichVergleichDerTechnologien.pdf} zeigt den Vergleich der einzeln evaluierten Servertechnologien.
			Auch hier haben wir zuerst je separat die Schätzung gemacht und dann verglichen.
			Bei diesem Vergleich haben wir gar noch ähnlichere Werte gewählt, lediglich bei den Zukunftsaussichten von PHP, Flow und Doctrine (blau markiert) hatten wir nennenswert unterschiedliche Ansichten.
			
			\begin{figure}
					\includegraphics[width=\textwidth]{media/img/EntwicklungVonWebserverTechnologien.png}
					\centering
					\caption{Entwicklung von Webserver"=Technologien der Top 10'000 Sites \cite{builtwith_pty_ltd_framework_2014}}
					\label{fig:EntwicklungVonWebserverTechnologien}
			\end{figure}
			
			Schlussendlich haben wir uns da nach Recherchen auf eine "`1"' geeinigt, weil entgegen den Erwartungen von Laurin Murer sich die Verbreitung von PHP (auch von den grösseren Seiten) kaum verändert hat.
			Als Beispiel für eine Technologie die am aussterben ist haben wir Shockwave Flash herangezogen, welche, wie in Abbildung~\ref{fig:EntwicklungVonWebserverTechnologien} sichtbar, im letzten Jahr deutlich an Boden verloren hat.
			Im Vergleich dazu ist PHP sehr gut im Markt vertreten und hat auch eine äusserst konstante Verbreitung.
			Deshalb und unter dem Gesichtspunkt von jungen modernen PHP Frameworks wie Doctrine und Flow sehen wir da auch die Zukunftsaussichten gegeben.
			
			\begin{figure}[H]
				\begin{minipage}[b]{\linewidth}
					\includegraphics[width=\textwidth]{media/spreadsheets/ServertechnologieVergleichVergleichDerTechnologienDiagramm.png}
					\centering
					\caption{Ergebnis Servertechnologie-Vergleich}
					\label{fig:ErgebnisServertechnologieVergleich}
				\end{minipage}
			\end{figure}
			
			Schlussendlich haben wir für jede Technologie das Total der Punkte berechnet (Punkte jedes Kriteriums multipliziert mit seiner Priorität). in Abbildung~\ref{fig:ErgebnisServertechnologieVergleich} zeigt man das finale Ergebnis. Aufgrund diesem haben wir uns für das Play Framework entschieden. Eine Alternative wäre noch Node.js mit TypeScript gewesen, doch dies hat bereits 10\%-Punkte weniger erreicht.

		\subsubsection{Play Framework}
			Kapitel~\ref{serverEvaluation} erläutert den Hintergrund der Entscheidung für das Play Framework. 
			Wikipedia beschreibt das Play Framework wie folgt:
			\begin{quote}
				"`Play is an open source web application framework, written in Scala and Java, which follows the model–view–controller (MVC) architectural pattern. It aims to optimize developer productivity by using convention over configuration, hot code reloading and display of errors in the browser."'\cite{builtwith_pty_ltd_framework_2014}
			\end{quote}
			
			
			Zusammenfassend führten die folgenden Gründe zur Entscheidung für das Play Framework:
			\begin{itemize}
				\item Das Play Framework basiert auch auf Java, wie das bestehende CDAR.
				\item Ein Teammitglied hat bereits Erfahrungen mit dem Framework gemacht.
				\item Das andere Teammitglied kennt die zugrundeliegende Sprache (Java).
				\item Der betreuende Dozent hat eine Präferenz für Java.
				\item Das Play Framework benötigt wenig Boilerplate-Code.
				\item Es sprechen keine zwingenden Gründe dagegen (wie beispielsweise zu stark einschränkende Lizenzen).
				\item Das Play Framework ist angenehm zum Entwickeln für die Entwickler: gegebener Spass-Faktor, Vermeidung von Fehlern, Unterstützung im Erreichen von guter Code Qualität.
			\end{itemize}

			

	\subsection{Client}
		\subsubsection{Sprache}
		\decision{
			\decisionHeader{T-C-1}{Clientseitige Programmiersprache}{Technologie}{Sprache}
		}{
			\decisionContent{TypeScript}
			{Welche Sprache soll clientseitig verwendet werden?}
			{}
			{Sprache soll guten Coden unterstützen, wenig Fehleranfällig sein, Fehler sollen frühzeitig erkannt werden}
			{
				\begin{description}
					\item[JavaScript] \
						\begin{description}
							\item[Vorteile] UI der bestehenden Applikation ist auch in JavaSscript geschrieben
							\item[Nachteile] Fehler tauchen erst zur Runtime auf, Sprachspezifische Besonderheiten, die Fehler begünstigen
						\end{description}
					\item[Dart] \
						\begin{description}
							\item[Vorteile] Moderne, optional typisierte, kompilierte Programmiersprache (wird zu JS kompiliert)
							\item[Nachteile] Benötigt Dart VM oder Dart-to-JS Transkompiler, wenig verbreitet
						\end{description}
				\end{description}
			}{TypeScript wird zu JavaScript kompiliert, sodass die Vorteile beide Sprachen kombiniert werden. TypeScript versucht, möglichst den Standard zukünftiger ECMA-Script Versionen einzuhalten, sodass die Kompatibilität immer gewährleistet und die Syntax möglichst ähnlich bleiben soll.
			\begin{description}
				\item[Vorteile] Optisch besser lesbar als JavaScript, verhindert bekannte, häufige Probleme in JavaScript wie z.B. das ungewohnte verhalten von "`this"', verbessert die Code Qualität gegenüber JavaScript massiv, da viele Fehler zur Kompilierzeit gefunden werden
				\item[Nachteile] Erfordert TSC-Compiler, Code Overhead bei Inheritance
			\end{description}
			}{}
			{Das Entwicklungsenvironment benötigt Node.js für den TypeScript Compiler.}
			{}
		}
			
			
		\subsubsection{Architektur-Framework}
			\decision{
				\decisionHeader{T-C-2}{Clientseitiges Applikationsframework}{Technologie}{Framework}
			}{
				\decisionContent{AngularJS}
				{Welches Applikationsframework soll clientseitig eingesetzt werden?}
				{}
				{Das Framework soll Templating unterstützen und Zwo-Way-Binding mit UI Komponenten unterstützen}
				{
					\begin{description}
						\item[EmberJS] \
							\begin{description}
								\item[Vorteile] Sehr Modular und anpassbar, weniger Overhead als AngularJS
								\item[Nachteile] Bringt wesentlich weniger mit als Angular JS, mehr Eigenaufwand notwendig
							\end{description}
						\item[Kein Framework] \
							\begin{description}
								\item[Vorteile] Vollständig freie Architekturgestaltung
								\item[Nachteile] Hoher Implementationsaufwand ohne Gewinn
							\end{description}
					\end{description}
				}
				{Angular JS ist ein bekanntes MVW- und Templating Framework, erlaubt eine saubere Trennung von Logik und Darstellung und bindet ViewModel Properties und Functions ans Template. Dadurch lassen sich Observerkonstrukte sparen.
				AgularJS ist stabil, zuverlässig, gut erweiterbar und bringt von sich aus schon sehr viel mit gegenüber EmberJS. Es wurde auch schon für die bestehende Applikation eingesetzt.}
				{}
				{Die Serverkomponente muss eine Schnittstelle bieten, über die die Clientapplikation Daten austauschen kann.}
				{}
			}
		
			
			\subsubsection{Require.js}
				Require.js eignet sich gut zur Strukturierung und zum Autolading der Klassen und komponenten, 
				insbesondere während der Entwicklung.

		\subsection{UI Frameworks}
			\subsubsection{LESS}
				Less soll als CSS Generator eingesetzt werden, da es den CSS Code stark verschlankt und Vorteile wie Variablen und Mixins bietet. LESS kann bei einem Node.js Server serverseitig compiled werden um den Client zu entlasten.
				
		\subsection{Testing}
			Testing Framework Anforderungen:
			\begin{itemize}
				\item Einfach einzubinden
				\item Einfach zu erweitern
				\item Bekannte Benutzung mit Tests und Asserts
				\item Möglichkeit zur Anbindung eines Build Tools
			\end{itemize}

			\subsubsection{JsUnit / QUnit}
				JsUnit wie QUnit arbeiten mit einem realen Browser (keine Browsersimulation), 
				sind einfach handzuhaben und bieten typische Assert-Syntax.
				
				
