\chapter{Projekt- und Qualitätsmanagement}
	\label{cap:projectmanagement}
	
	Zur Verwaltung des Projektes hat das Projektteam ein Jira eingesetzt.
	
	\section{Projektmanagement}
		Zur Grobplanung und zur Planung der Meilensteine wurden Jira-Versions eingesetzt.
		
		\begin{figure}[H]
			\includegraphics[width=\textwidth]{projectPlan/media/img/jiraVersions.jpg}
			\centering
			\caption{Jira Versions/Meilensteine}
			\label{fig:jiraVersions}
		\end{figure}
		
		Features haben wir in Zusammenarbeit mit dem Vertreter der Kundengruppe priorisiert und daraus resultierende Issues Meilensteine zugeordnet.
		Zur Strukturierung haben wir zusätzlich Labels eingesetzt.
		
		\begin{figure}[H]
			\includegraphics[width=\textwidth]{projectPlan/media/img/jiraIssuesOpenOrTodo.jpg}
			\centering
			\caption{Jira Issues, sortiert nach Version}
			\label{fig:jiraIssuesOpenOrTodo}
		\end{figure}
		
		Anhand den geschätzten Aufwänden
		pro Issue und der zur Verfügung stehenden Zeit eines Meilensteine haben wir jeweils eine Meilensteinplanung durchgeführt.		
		Dabei haben wir maximal 2/3 der zur Verfügung stehenden Zeit für
		Issues eingeplant und den Rest für Unvorhergesehenes, 
		Meetings und Planung vorgesehen.
		
		\begin{figure}[H]
			\includegraphics[width=\textwidth]{projectPlan/media/img/jiraDashBoard.jpg}
			\centering
			\caption{Jira Dashboard}
			\label{fig:jiraDashBoard}
		\end{figure}
		
		Jira bietet anpassbare Dashboards, 
		die einen Überblick über das laufende Projekt bieten.
		
		Der Activity Stream von Jira sowie die Git History ermöglichten es uns auf einfache Weise nachzuvollziehen,
		an was der Teampartner in den letzten Stunden gearbeitet hat. 
		Dies senkt den Kommunikationsaufwand und die Notwendigkeit,
		jederzeit gemeinsam an einem Ort zu arbeiten.
		
		\begin{figure}[H]
			\includegraphics[width=\textwidth]{projectPlan/media/img/gitHistory.jpg}
			\centering
			\caption{Git History in SmartGit}
			\label{fig:gitHistory}
		\end{figure}
		
		Für grössere Features haben wir Git Flow Featurebranches eingesetzt.
		Für Releases entsprechend Releasebranches.
		Zusätzliche haben wir die Funktion "'Releases"' von Github
		zum Hinzufügen von fertigen Builds zu Releases genutzt.
		
		\begin{figure}[H]
			\includegraphics[width=0.5\textwidth]{projectPlan/media/img/githubReleases.jpg}
			\centering
			\caption{Github Releases mit Build-Archives}
			\label{fig:githubReleases}
		\end{figure}
	
		
	\section{Qualitätssicherung}
		Um sicherzustellen, dass keine Issues geschlossen werden,
		ohne dass die Arbeit einem Review unterzogen wurde,
		haben wir den Issue Workflow im Jira entsprechend gestaltet.		
		
		\begin{figure}[H]
			\includegraphics[width=0.5\textwidth]{projectPlan/media/img/jiraIssueWorkflow.jpg}
			\centering
			\caption{Angepassten Jira Issue-Workflow}
			\label{fig:jiraIssueWorkflow}
		\end{figure}
		
		Fertig gestellte Issues müssen immer dem andern Teammitglied
		zum Review gesandt werden und tauchen entsprechend auf dessen
		Dashboard als "'Ready to Review"' auf.
		
		Es geht dabei nicht darum, 
		für jeden erledigten Issue den kompletten Code des Andern anzusehen, 
		sondern das Resultat grob anzuschauen und eventuell
		Edge-Cases\footnote{Spezialfälle, bezogen auf Input Daten oder 
		Workflows der grafischen Oberfläche} zu prüfen. 
		Ein komplettes Code Review jedes Issues wäre zeitlich nicht verhältnismässig.
		
		% TODO:explain used tools in infrastructure
		\section{Testkonzept}
		
			Um zuverlässig alle notwenigen Bereiche mit Tests abzudecken, 
			werden folgende Tests durchgeführt:
			
			\begin{description}
				\item[Unit (Unit- /Logiktests)] Tests, die eine einzelne Klasse, 
					Service oder Komponente testen. 
					Andere Klassen sind nur soweit Teil des Tests, 
					wie dies aufgrund der Abhängigkeiten notwendig ist.
				\item[Integration (Integrationstests)] Tests, die das Zusammenspiel zwischen Klassen, 
					Komponenten und Services testen. 
					Diese Tests können über mehrere Layers bis mehrere Tiers laufen.
					Alle API-Aufrufe werden mit solchen Tests getestet.
				\item[Behaviour (Verhaltenstests)] Gross-Integrationstests, 
					die über alle Tiers und Layers laufen. 
					Diese Tests testen Workflows von der Persistenz 
					bis zur grafischen Ausgabe im Userinterface. 
					Dazu wird mit Selenium ein Browser gestartet und dessen Ausgabe analysiert.
					%TODO: evtl. User-Stories testen
			\end{description}