\chapter{Infrastruktur}
	\section{Hardware}
		\begin{itemize}
			\setlength{\itemsep}{-\parsep}
			\item Persönliche Entwicklungsgeräte für jedes Teammitglied, bevorzugt Laptop (eigene Geräte)
			\item Zugewiesene Arbeitsplätze im Zimmer 1.206
			\item Virtual Server für Projektmanagement und Virtueller Server als Entwicklungsserver
		\end{itemize}

		
	\section{Tools}
		\subsection{Projektmanagement}	
			Jira und Redmine bieten identische Funktionalität und es wurden sowohl mit Jira wie mit Redmine gute Erfahrungen gemacht. Redmine ist in der Basiskonfiguration eher auf RUP ausgerichtet, für Agile Entwicklung werden Plugins benötigt. Jira ist in der Basiskonfiguration auf Agile Entwicklung ausgerichtet. Die Bentzeroberfläche von Jira ist etwas moderner und benutzerfreundlicher gestaltet, ansosten sind sich beide Oberflächen jedoch ähnlich.
		
			\begin{description}
				\item[Evaluierte Produkte] Jira, Redmine
				\item[Ausgewähltes Produkt] Jira
				\item[Begründung] Jira bietet eine benutzerfreundliche Oberfläche, die erforderlichen Funktionalität sowie ist grundsätzlich auf Agile Entwicklung ausgerichtet
			\end{description}


		\subsection{Versionsverwaltung}
			\subsubsection{Git}
				Git ist ein bewährtes Versionsverwaltungstool, bietet den Vorteil von lokalen Repositories, ist sehr schlank und bringt eine gute Merge-Automatik mit.

			\subsubsection{GitHub}
				Mit GitHub besitzen die Studenten durch andere Projekte bereits Erfahrung. Als
				Studenten haben sie Zugriff auf kostenlose "`Private-Repositories"'. Zudem
				bietet GitHub noch zusätzliche Funktionen wie Wiki, RST- und MD-Viewer sowie
				Repository-Zugriff und Dateibearbeitung über ein Webinterface.
				
			\subsubsection{Git Flow}
				Git Flow automatisiert häufige Git Operationen für einen Entwicklungs Workflow mit Master-, Develop-, und Featurebranches.

			\subsubsection{Backup}
				Ein zusätzliches Backup ist nicht notwendig, da durch die Versionierung mit Git die komplette Versionshistorie bei jedem Teilnehmer vorhanden ist. Somit ist das gesamte Projekt dreifach abgelegt (bei den Entwicklern sowie bei GitHub).


		\subsection{Dokumentation}
			\subsubsection{Für grosse Dokumentationen und Abgabedokumente: \LaTeX}
				\LaTeX\ ist perfekt geeignet für grosse, gemeinsam zu erarbeitende Dokumente,
				weil die Source-Dateien über Git versioniert und gemergt werden können und wenig
				Platz verbrauchen. Zudem besteht ein sehr kleines Risiko auf Dokumentenverlust
				bzw. Dokumentenfehler durch die Software, weil \LaTeX\ die Source-Dateien gar
				nicht verändert, im Unterschied zu einer Office-Applikation.

			\subsubsection{Für Notizen \& Meetingprotokolle: Restructured Text (rst), txt, Markdown (md)}
				Für Notizen und kleine Dokumente reichen RST, TXT oder MD vollständig aus. Sie
				sind schlank, bieten nur das notwendigste, können versioniert und gemergt
				werden, weil es nur Textfiles sind, und werden von "`GitHub Document aPreview"'
				unterstützt.

			\subsubsection{Für Diagramme, Skizzen: LibreOffice Draw (OpenDocument)}
				Wo es nicht anders geht, wird OpenDocument eingesetzt. Dabei wird
				berücksichtigt, dass es über Git nicht inkrementell versioniert und nicht
				gemerged werden kann.


		\subsection{Modeling}
			Als Modeling-Tool wird Astah gewählt, weil es das beste den Studenten
			bekannte Tool ist.
			Es deckt den geforderten Funktionsumfang grosszügig ab und bietet Image- sowie
			PDF-Export.

			
		%\subsection{UI Drafting}
		


		\subsection{Frameworks}
			\subsubsection{Angular.js}
				Angular.js ist ein bekanntes MVW- und Templating Framework, das eine saubere Trennung von Logik und Darstellung ermöglicht. Angular.js bindet darüber hinaus ViewModel Properties und Functions ans Template, wodurch sich Observerkonstrukte sparen lassen.

			\subsubsection{Require.js}
				Require.js soll zur Strukturierung und Autolading der Klassen und komponenten eingesetzt werden.

			\subsubsection{LESS}
				Less soll als clientseitiger CSS Parser eingesetzt werden, da es den CSS Code stark verschlankt und Vorteile wie Variablen und Mixins bietet.


		\subsection{Testing}
			Testing Framework Anforderungen:
			\begin{itemize}
				\setlength{\itemsep}{-\parsep}
				\item Testing mit realem Browser, Browsersimulationen unterstützen vermutlich WebRTC noch nicht
				\item Einfach einzubinden
				\item Einfach zu erweitern
				\item Bekannte Benutzung mit Tests und Asserts
				\item Möglichkeit zur Anbindung eines Build Tools
			\end{itemize}

			\subsubsection{JsUnit / QUnit}
				JsUnit wie QUnit arbeiten mit einem realen Browser, sind einfach handzuhaben und bieten typische Assert-Syntax.


		\subsection{Building}
			Ein Build-Server wie Ant ist nicht nötig für dieses Projekt. JsUnit bietet zwar
			eine Anbindungsmöglichkeit. Für unsern Anwendungsfall und die nicht sehr
			komplexe Tool-Umgebung lohnt sich der Aufwand eines Build-Servers jedoch nicht.


		\subsection{Entwicklungsumgebung}
			Jeder Entwickler verwendet seine eigene bevorzugte Entwicklungsumgebung. 


		\subsection{RunTime Environment}
			\begin{description}
				\item[Ausgewähltes Environment] Virtuellem Linux Server (Ubuntu Server 14.04, Virtualbox, Vagrant), installiert auf den von der IT zur Verfügung gestellten Workstations.
				\item[Begründung]	 Die Workstations sind über öffentliche Adressen erreichbar und unterliegen weniger Einschränkungen als die von der IT zur Verfügung gestellte Virtuelle Server. So können von der IT extern geblockte Ports auf dem eigenen Server vom lokal Netz aus trotzdem genutzt werden. Zudem müssen auch die Virtuellen Server der IT selbst verwaltet und gebackupt werden wodurch sich keine wirklichen Vorteile bei deren Nutzung ergeben.
			\end{description}
